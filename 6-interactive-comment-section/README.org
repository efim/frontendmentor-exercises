* Frontend Mentor - Interactive comments section solution
:PROPERTIES:
:CUSTOM_ID: frontend-mentor---interactive-comments-section-solution
:END:
This is a solution to the
[[https://www.frontendmentor.io/challenges/interactive-comments-section-iG1RugEG9][Interactive
comments section challenge on Frontend Mentor]]. Frontend Mentor
challenges help you improve your coding skills by building realistic
projects.

** Overview
:PROPERTIES:
:CUSTOM_ID: overview
:END:
*** The challenge
:PROPERTIES:
:CUSTOM_ID: the-challenge
:END:
Users should be able to:

- View the optimal layout for the app depending on their device's screen
  size
- See hover states for all interactive elements on the page
- Create, Read, Update, and Delete comments and replies
- Upvote and downvote comments
- *Bonus*: If you're building a purely front-end project, use
  =localStorage= to save the current state in the browser that persists
  when the browser is refreshed.
- *Bonus*: Instead of using the =createdAt= strings from the =data.json=
  file, try using timestamps and dynamically track the time since the
  comment or reply was posted.

*** Screenshot
:PROPERTIES:
:CUSTOM_ID: screenshot
:END:
[[./screenshot.png]]
*** Links
:PROPERTIES:
:CUSTOM_ID: links
:END:
- [[https://www.frontendmentor.io/solutions/grid-tailwind-webcomponent-in-scalajs-and-laminar-with-vite-Wvdajlo_Sj][Solution URL]]
- [[https://efim-frontendmentor-interactive-comment-section.pages.dev/][Live Site URL]]

** My process
:PROPERTIES:
:CUSTOM_ID: my-process
:END:
*** Built with
:PROPERTIES:
:CUSTOM_ID: built-with
:END:
- TailwindCSS
- Flexbox
- Mobile-first workflow
- @github webcomponent "relative-time"
- ScalaJS
- Laminar
- Vite

*** What I learned
**** used Grid layout for the "very different" mobile & desktop
Good thing I cought this early - the layouts of mobile and desktop are *very* different!
The placement of voting controls, and reply\edit controls in relation to header and message text are totally not similar.

Luckily I've already head about "Grid" layour, and read a bit about it in TailwindCSS docs,
so imagining Message Component as 3x3 with sub-elements occupuing different rows\columns was a success.

There's also a link to free course on the frontendmentor: https://cssgrid.io/
**** using quicklens for modifying nested immutable instances
Scala and functional programming are pleasant in big part due to immutable structures.
It's nice to be sure that what you get as input is something immutable, and just return a modified copy.

Things get harder with nested classes. Lenses to the rescue:
libraries give autogenerated methods, that allow to "create new immutable modified instance" with minimal sintactical overhead:
#+begin_src scala
state.modify(_.comments.at(commentUid).replies)(replies =>
    replies.updated(reply.message.id, reply)
)
#+end_src

awesome examples in the [[https://github.com/softwaremill/quicklens][official doc]]

**** using java.time in ScalaJS
Import of java classes often doesn't work out of the box,
but with additional dependency
"https://github.com/cquiroz/scala-java-time"
included into 'build.sbt'
#+begin_src scala
aryDependencies += "io.github.cquiroz" %%% "scala-java-time" % "2.5.0",
#+end_src

we can now use awesome =java.time=
With local date times, arythmetic, and cool things like separate abstractions for [[https://docs.oracle.com/javase/tutorial/datetime/iso/period.html][Duration and Period]].

**** adding github "relative-time" webcomponent
Webcomponents is awesome new tech that allows to encapsulate js logic, styling and markup into a "custom tag" which can be used from any framework \ technology.

I've already heard about githubs "local date time" which significantly simplifies display of time, when you need to account for TimeZome of user.

In this project I was helped by "relative datetime" - which displays timestamps as "now", "7 minutes ago", "2 months ago", and "January 3rd".

Docs: https://github.com/github/relative-time-element
***** installation:
#+begin_quote
npm install @github/relative-time-element
#+end_quote
***** how I want the tag (generated by Laminar and ScalaDom)
#+begin_src html
<relative-time datetime="2014-04-01T16:30:00-08:00">
  April 1, 2014
</relative-time>
#+end_src

just name and =datetime= attribute
(no need for events, or something more complicated)
***** i created tag and attribute:
  #+begin_src scala
  val relativeTimeTag = htmlTag("relative-time")
  val relTimeDatetime = htmlAttr("datetime", StringAsIsCodec)
  #+end_src

and then used it:
        #+begin_src scala
        div(
        className := "pl-3 text-light-gray",
        child <-- messageSignal.map(message => {
          val scalaInstant = message.createdAt
          val isoTime =
            java.time.Instant.ofEpochSecond(scalaInstant.getEpochSecond())
          relativeTimeTag(
            scalaInstant.toString().take(10),
            relTimeDatetime := isoTime.toString()
          )
        })
        #+end_src

Also!
Laminars dynamic bindings of value streams into webcomponent attributes should work out of the box (if webcomponent implements 'on-attr-change' functions).
But I'm not sure yet how to work with events to and from components.
***** and for some reason i needed:
in my =index.html=
  #+begin_src html
  <!-- TODO i have no idea why code doesn't work without it --
    -- in the console i see 'already-registered' -->
  <script type="module">
    import RelativeTimeElement from '/node_modules/@github/relative-time-element/dist/index.js';
    if (!window.customElements.get('relative-time')) {
      window.customElements.define('relative-time', RelativeTimeElement);
    } else { console.log("already-registered") }
  </script>
  #+end_src

This is very strange. Without that script the =<relative-time>= only showed the default value, with it - worked.
But in the console I saw "already-registered", so it wasn't really necessary.
I'll figure this out eventually.

**** attempted to use .zoom to get "derived vars"
"[[https://github.com/raquo/Airstream/#derived-vars][derived var]]" is very cool thing where i have Var (stream and setter), and I can get Var of some part of that state to pass into child components or some functions, so that they wouldn't have to consider whole state.
***** this is how I attempted to use it:
But zoom needs "owner" (Laminar feature to allow for efficient cleaning up stream subscriptions - in most cases done automatically), and I can't create the CommentComponent without that zoomed var,
so it seems to be like chicken and an egg - if I want the child component to be an "owner" of the Var subscription.

I found how to get "owner" from the parent component, so something like this works:

#+begin_src scala
import com.softwaremill.quicklens._

object MessageComponent {
  def render(messageVar: Var[Message]): Element = {
    messageVar.update(st => st.modify(_.content).setTo("in the element"))

    div(
      child.text <-- messageVar.signal.map(_.toString())
    )
  }
}

// and then in Main file
    val hardcoded =
      Models.hardcoded.modify(_.comments.at(0).message.content).setTo("Hello")
    val stateVar = Var(hardcoded)
    div(
      onMountInsert(ctx => {
        val commentVar: Var[Models.Message] = stateVar.zoom(_.comments.head.message)((state, newMessage) => {
          state.modify(_.comments.at(0).message).setTo(newMessage)
        })(ctx.owner)

        MessageComponent.render(commentVar)
      }),
    )
  }
#+end_src

but then, all of the Vars, than CommentComponent use, will be active even though some of the CommentComponents get removed, right?

With this wrapper div things don't look too bad,
maybe doing .zoom in the parent would be a little bit cleaner because CommentComponent wouldn't have to know about all potential wider scopes that can be zoomed to Comment,
but if there's no other way (apart from all CommentComponents using parents owner on zoomed var) this seems good enough?
#+begin_src scala
import com.softwaremill.quicklens._

object MessageComponent {
  def render(messageVar: Var[Message]): Element = {
    messageVar.update(st => st.modify(_.content).setTo("in the element"))

    div(
      child.text <-- messageVar.signal.map(_.toString())
    )
  }

  // of course it would take CommentID for the general case, or other way to locate component
  def prepareTopLevelCommentComponent(stateVar: Var[AppState]): Element = {
    div(
      onMountInsert(ctx => {
        val commentVar: Var[Models.Message] =
          stateVar.zoom(_.comments.head.message)((state, newMessage) => {
            state.modify(_.comments.at(0).message).setTo(newMessage)
          })(ctx.owner)
        MessageComponent.render(commentVar)
      })
    )
  }
}

// and in Main file

val hardcoded =
    Models.hardcoded.modify(_.comments.at(0).message.content).setTo("Hello")
val stateVar = Var(hardcoded)
div(
    className := "w-screen h-screen",
    MessageComponent.prepareTopLevelCommentComponent(stateVar),
)
#+end_src
***** and then decided against it
Passing =Signal[SubState]= into child component, and some callbacks to modify attributes in the overall state is simple enough!

I can create modification callbacks with lenses, and just use =.map= on =Signal[State]= to get signal for sub-state.
#+begin_src scala
def updateComment(commentUid: String)(f: Comment => Comment): Unit = {
    stateVar.update(_.modify(_.comments.index(commentUid))(f))
}
#+end_src
***** and actual application would be even simpler!
In actual application, I'll have single =Signal[AppState]= created at the top, from the websocket from backend, and all of child components would only need =Signal[SubState]= and no callbacks would be necessary:

subcomponets can just issue http requests to backend, and new state would arrive via websocket.
**** got to use "modal" html element
which i first heard in the 'webdev simplified" channel:
https://blog.webdevsimplified.com/2023-04/html-dialog/
#+begin_src scala
    val deletionDialog = dialogTag(
      className := "backdrop:bg-black/50",
      form(
        method := "dialog",
        p("Are you sure?"),
        button(
          `type` := "submit", // html logic, will close modal, and not submit form
          onClick --> Observer(_ => onDelete()),
          onClick --> Observer(_ => println("submittign form")),
          "YES, DELETE"
        ),
      )
    )

    div(
      className := "flex flex-row items-center",
      deletionDialog, // put dialog into dom
      button(
        className := "flex flex-row items-center mr-7 text-sm font-bold text-soft-red",
        onClick --> Observer(_ => deletionDialog.ref.showModal()), // acces dom ref, it's already typed. wow
        "Delete"
      ),
    )
#+end_src
***** and found out about TailwindCSS color opacity configuration:
#+begin_src scala
className := "backdrop:bg-light-gray/75",
#+end_src

*** Continued development
:PROPERTIES:
:CUSTOM_ID: continued-development
:END:
In future studies, I'd want to:
1. Better breakdown into components.
   current solution seems bogged down in the "MessageComponent",
   with bits of differences between "Comment" and "Reply" encoded as conditionals based on the constructor arguments.
2. Better understanding of when to pass in Stream, and when - single element.
   or simpler way to "peek" at current stream value, like "currentUser" so that it could be used in all bindings of component.
3. More use of webcomponents. Better understanding of their initialization, integration of more complex components into Laminar.
   Maybe something "draggable" or something.
4. Would be nice to have Comment Messages be <h1> and reply messages be <h2>
5. Maybe learn how to do testing?

** Acknowledgments
:PROPERTIES:
:CUSTOM_ID: acknowledgments
:END:
Certainly ChatGpt helped me, at least with strange webcomponent initialization script, but also talking about css styling, and other things.
